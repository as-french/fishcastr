#' Generate simulated values from bbmle::mle2 model
#'
#' @description This function generates simulations from a fitted bbmle::mle2
#'   (Bolker & R Core Team 2017) model object. Simulations are returned as a
#'   matrix. The stochastic element of the simulations comes from randoms draws
#'   from the conditional distribution of the response (e.g., generalised
#'   Poisson distribution). However, mean predictions are generated by
#'   simulation from a multivariate normal distribution, and 95% confidence
#'   intervals of this mean (i.e., population prediction intervals) are
#'   generated within this function, but not currently returned.
#'
#' @importFrom gamlss.dist dNBII rNBII
#' @importFrom RMKdiscrete sLGP dLGP
#' @param fittedModel A bbmle::mle2 object.
#' @param n Number of simulations of mle2 object.
#' @param count_lab Name of response variable.
#' @param sim_seed A random seed.
#' @param fittedModel_name Default NULL. Experimental.
#' @param fittedModel_curve_name Character string currently "Cauchy",
#'   "exp_mod_Gauss" or exp_mod_Gauss_inv.
#' @param newdata Default NULL. Experimental.
#' @param ... Other arguments to nested functions.
#' @return A matrix of simulations.
#' @references
#' Bolker, B. & R Core Team. (2017). bbmle: Tools for General Maximum Likelihood
#' Estimation (R package version 1.0.20).
#' https://CRAN.R-project.org/package=bbmle
#' @examples
#' \dontrun{
#' simulate_mle(fittedModel = mle2_mod,
#'              n = 250,
#'              count_lab = "ssmolt",
#'              sim_seed = 123,
#'              fittedModel_name = NULL,
#'              newdata = NULL)
#' }
#' @export
simulate_mle <- function(fittedModel,
                         n,
                         count_lab,
                         sim_seed,
                         newdata = NULL,
                         fittedModel_name = NULL,
                         fittedModel_curve_name,
                         ...){

#  dNBII <- gamlss.dist::dNBII
#  dLGP <- RMKdiscrete::dLGP
#  dnbinom <- stats::dnbinom

#  suppressMessages(require(RMKdiscrete)) # could be useful for dgenpoiss...
#  suppressMessages(require(bbmle)) # could be useful for dgenpoiss...

  old_state <- get_rand_state()
  on.exit(set_rand_state(old_state))

  # extract family (for more efficient random deviate production for generalised Poisson mle built in function slow to simulate)
#  suppressMessages(require(qdapRegex))
  form = fittedModel@formula
  fam = qdapRegex::ex_between(form, "~", "(")[[1]]

  if(fam == "dLGP" & fittedModel_curve_name == "exp_mod_Gauss"){
    # ----------------------------------------------------------
    # obtain mean by simulation
    vmat = MASS::mvrnorm(1000, mu = bbmle::coef(fittedModel), Sigma = bbmle::vcov(fittedModel))
    dist = matrix(nrow = length(fittedModel@data[[2]]), ncol = 1000)
    for (i in 1:1000) {
      dist[,i] =  exp_mod_Gaussian_resp(x = fittedModel@data[[2]],
                                        c = vmat[i, "c"],
                                        mu_exmg = vmat[i, "mu_exmg"],
                                        sigma_exmg = vmat[i, "sigma_exmg"],
                                        lamb = vmat[i, "lamb"])
    }

    dist_quantiles <- cbind(fittedModel@data[[2]],t(apply(dist, MARGIN = 1, FUN = quantile, probs = c(0.025,0.50, 0.975))),
                            (apply(dist, MARGIN = 1, FUN = mean)))
    colnames(dist_quantiles) <- c("x","lwr_CI","median","upr_CI","mean")
    preds_physio <- dist_quantiles[,"mean"]

    # ----------------------------------------------------------
    # simulate... n times
    sim_values_list <- lapply(1:n, function(z){
      set.seed(as.integer(sim_seed)+z)
      result <- rgenpoisson(mu = preds_physio,
                            disp_param = bbmle::coef(fittedModel)[["phi"]])
      return(result)
    })

    sim <- do.call(cbind, sim_values_list)
    return(sim)
  }

  if(fam == "dLGP" & fittedModel_curve_name == "exp_mod_Gauss_inv"){
    # ----------------------------------------------------------
    # obtain mean by simulation
    vmat = MASS::mvrnorm(1000, mu = bbmle::coef(fittedModel), Sigma = bbmle::vcov(fittedModel))
    dist = matrix(nrow = length(fittedModel@data[[2]]), ncol = 1000)
    for (i in 1:1000) {
      dist[,i] =  exp_mod_Gaussian_resp_inv(x = fittedModel@data[[2]],
                                        c = vmat[i, "c"],
                                        mu_exmg = vmat[i, "mu_exmg"],
                                        sigma_exmg = vmat[i, "sigma_exmg"],
                                        lamb = vmat[i, "lamb"])
    }

    dist_quantiles <- cbind(fittedModel@data[[2]],t(apply(dist, MARGIN = 1, FUN = quantile, probs = c(0.025,0.50, 0.975))),
                            (apply(dist, MARGIN = 1, FUN = mean)))
    colnames(dist_quantiles) <- c("x","lwr_CI","median","upr_CI","mean")
    preds_physio <- dist_quantiles[,"mean"]

    # ----------------------------------------------------------
    # simulate... n times
    sim_values_list <- lapply(1:n, function(z){
      set.seed(as.integer(sim_seed)+z)
      result <- rgenpoisson(mu = preds_physio,
                            disp_param = bbmle::coef(fittedModel)[["phi"]])
      return(result)
    })

    sim <- do.call(cbind, sim_values_list)
    return(sim)
  }

  if(fam == "dLGP" & fittedModel_curve_name == "Cauchy"){
    # ----------------------------------------------------------
    # obtain mean by simulation
    vmat = MASS::mvrnorm(1000, mu = bbmle::coef(fittedModel), Sigma = bbmle::vcov(fittedModel))
    dist = matrix(nrow = length(fittedModel@data[[2]]), ncol = 1000)
    for (i in 1:1000) {
      dist[,i] =  Cauchy_resp(x = fittedModel@data[[2]],
                                        gamma = vmat[i, "gamma"],
                                        x0 = vmat[i, "x0"])
    }

    dist_quantiles <- cbind(fittedModel@data[[2]],t(apply(dist, MARGIN = 1, FUN = quantile, probs = c(0.025,0.50, 0.975))),
                            (apply(dist, MARGIN = 1, FUN = mean)))
    colnames(dist_quantiles) <- c("x","lwr_CI","median","upr_CI","mean")
    preds_physio <- dist_quantiles[,"mean"]

    # ----------------------------------------------------------
    # simulate... n times
    sim_values_list <- lapply(1:n, function(z){
      set.seed(as.integer(sim_seed)+z)
      result <- rgenpoisson(mu = preds_physio,
                            disp_param = bbmle::coef(fittedModel)[["phi"]])
      return(result)
    })

    sim <- do.call(cbind, sim_values_list)
    return(sim)
  }

#  if(fam != "dGPO"){
  if(fam != "dLGP"){

    # ----------------------------------------------------------
    # simulate... n times
    #n = 1
    sim_values_list <- lapply(1:n, function(z){
      set.seed(as.integer(sim_seed)+z)

      #View(fittedModel)

      result <- bbmle::simulate(fittedModel)
      return(result)
    })
    sim <- do.call(cbind, sim_values_list)

    return(sim)
  }


}
