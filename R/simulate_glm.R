#' Generate simulated values from glmmTMB::glmmTMB model
#'
#' @description This function generates simulations from a fitted
#'   glmmTMB::glmmTMB model object when supplied with "newdata". (adapted from
#'   Ben Bolker's answer to a question on stackoverflow under creative commons
#'   (CC-BY-SA 4.0; https://creativecommons.org/licenses/by-sa/4.0/):
#'   https://stackoverflow.com/questions/55230145/passing-new-data-to-simulate-glmmtmb))
#'
#' @param object A glmmTMB::glmmTMB object.
#' @param nsim Number of simulations to generate from glmmTMB object.
#' @param X A data.frame with names matching those in formula of object.
#' @param seed A random seed.
#' @param pred_type A character string "predict" or "simulate" to generate
#'   conditional mean, or random deviates, respectively.
#' @param zinf Boolean. Default FALSE, but function checks and alters this
#'   automatically in the case of glmmTMB objects.
#' @param PIs Boolean. Default FALSE. If "predict", generates mvrnorm based
#'   population prediction intervals (see B Bolker's Ecological Models and Data
#'   with R.); i.e., uncertainty in conditional mean owing to parameter
#'   uncertainty. If "simulate, generates bootstrapped 95% prediction intervals,
#'   whereby 999 random deviates are generated from a point estimate conditional
#'   mean and 0.025 and 0.975 percentiles are extracted using quantiles().
#' @param lapply_seed A random seed used for parallel processing. Default 123.
#' @param parallel Boolean. Default FALSE. Use parallel processing?
#' @param use_random_seed Boolean. Default FALSE. Experimental.
#' @param ... Arguments to nested functions.
#' @return If "pred_type = predict", a list containing two elements. The element
#'   "fitted_y" is a list of four vectors ("pred.ucount.sim", a single simulated
#'   mean based on a single mvrnorm sample; "mean.count", the mean calculated
#'   from of 999 mvrnorm simulations (i.e., the conditional (on fixed effects
#'   only) mean of the model; "ci.ucount_lwr", the 0.025 percentile of 999
#'   mvrnorm simulations; "ci.ucount_upr", the 0.975 percentile of 999 mvrnorm
#'   simulations. The element "fitted_y_old" is generated for
#'   checking/comparison and is the predicted (conditional mean) generated by
#'   the "base::predict()" function - this may be removed at a later date. If
#'   "pred_type = simulate", a single vector of simulations is produced (i.e., a
#'   single vector of random deviates based on the model's specified error
#'   distribution; e.g., glmmTMB::nbinom1). This simulation does not take into
#'   account parameter uncertainties, rather, all values are generated assuming
#'   a point estimated mean derived from the "base::predict" function and a
#'   random deviate generator (e.g., gamlss.dist::rNBII). If "PIs = TRUE" AND
#'   "pred_type = simulate", the function returns a list containing three
#'   vectors (95% bootstrapped percentile confidence intervals derived from 999
#'   random deviates ("low_PI" and "upper_PI") and a bootstrapped "median". If
#'   "PIs = TRUE" AND "pred_type = predict", no additional data are returned.
#' @examples
#' \dontrun{
#' mTrain_genpois <- readRDS(paste0(system.file("vignettes", package = "fishcastr"),
#'                                 "/vignette_data/mTrain_genpois_salmon_2019.rds"))
#' newdata <- mTrain_genpois$frame
#' newdata <- newdata[newdata$salmonid_year %in% c(2012:2013),]
#' result <- simulate_glm(object = mTrain_genpois,
#'                              X = newdata,
#'                              pred_type = "predict")
#'                              }
#' @export
simulate_glm <- function(object,
                         nsim=1,
                         seed=NULL,
                         X,
                         pred_type,
                         zinf = FALSE,
                         PIs = FALSE,
                         lapply_seed = 123,
                         parallel = FALSE,
                         use_random_seed = FALSE,
                         ...) {

  # extract family from object
  cond_family <- family(object)[[1]]

  if(class(object) == "lm" & pred_type == "predict"){
    new_data <- data.frame(X)
    names(new_data) <- names(coef(object)[2])
    fitted_y <- predict(object, newdata = new_data , na.action = na.omit)

  }
  if(class(object) == "glmmTMB" & pred_type == "predict"){
    new_data = X
    # obtain fitted values (i.e., conditional means, unconditional on random
    # effects, but conditional on fixed effects)
    fitted_y_old <- predict(object, newdata = new_data, allow.new.levels=TRUE, type = "response", na.action = na.pass, re.form = NA)

    # mean expectation (counts) that takes into account parameter uncertainties
    # and is based on mvrnorm sampling of glmmTMB parameter estimates - note
    # that random effect point estimate is used (i.e, 0), rather than taking
    # into account random effect parameter uncertainty (this is sometimes
    # referred to a "unconditional" prediction intervals)

    fitted_y <- fishcastr::predict_ucount_ci(model = object,
                                  interval = c(0.025,0.975),
                                  dataset = new_data)

    return(list(fitted_y = fitted_y,
                fitted_y_old = fitted_y_old))
  }

  if(class(object) == "lm" & pred_type == "simulate"){
    object$fitted.values <- fitted_y
    if(parallel == FALSE){
    #set.seed(as.integer(lapply_seed))
    }
    sim_values <- stats::simulate(object=object, nsim=nsim, seed=seed, ...)[,1]
  }

  if(class(object) == "glmmTMB" & pred_type == "simulate"){

    # extract if zero inflated or not
    zero_inf_y_n <- formula(object, component = c("zi"))
    zinf <- ifelse(zero_inf_y_n == "~0",
                   FALSE,
                   TRUE)

    # extract if dispersion parameter is modelled by (/a function of) fixed effects
    dispform_y_n <- formula(object, component = c("disp"))
    disp_form <- ifelse(dispform_y_n == "~0",
                   "zero",ifelse(dispform_y_n == "~1","one","modelled"))

    new_data = X
    fitted_y <- predict(object, newdata = new_data, allow.new.levels=TRUE, type = "response", na.action = na.pass, re.form = NA)

    if(cond_family == "gaussian" & zinf == FALSE){
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      #sim_values <- stats::rpois(n = nrow(new_data), mean = fitted_y, sd = glmmTMB::sigma(object))
      sim_values <- stats::rpois(n = nrow(new_data), lambda = fitted_y)

    }

    # ALTERNATIVE MANUAL METHOD poisson
    if(cond_family == "poisson" & zinf == TRUE){

      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      zi_prob <- predict(object, newdata=new_data, type="zprob", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)

      # generate random counts from quasi-poisson (nbinom1) dist
#      suppressMessages(require(gamlss.dist))
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      cond <- stats::rpois(n = nrow(new_data),
                    lambda = cond_mean)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      #set.seed(12345)
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      sim_values <- ifelse(stats::runif(nrow(new_data))< zi_prob, 0, cond)

      # -------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        #sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
       # suppressMessages(require(gamlss.dist))
        # for(i in 1:999){
        #   cond <- stats::rpois(n = nrow(new_data),
        #                 lambda = cond_mean)
        #
        #   sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #
        #   # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #   sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        # }
        #set.seed(12345)

        sim_values_list <- lapply(1:999, function(z){
          #if(parallel == FALSE){
          #set.seed(as.integer(lapply_seed)+z)
          #}
          cond <- stats::rpois(n = nrow(new_data),
                        lambda = cond_mean)
        })
        sim_values_mat <- do.call(cbind, sim_values_list)

        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025))
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975))
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500))
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    if(cond_family == "poisson" & zinf == FALSE){

      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      #        zi_prob <- predict(object, newdata=new_data, type="zprob", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)

      # generate random counts from quasi-poisson (nbinom1) dist
#      suppressMessages(require(gamlss.dist))
      #set.seed(12345)
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      cond <- stats::rpois(n = nrow(new_data),
                    lambda = cond_mean)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      sim_values <- cond

      # -------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        #       sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
#        suppressMessages(require(gamlss.dist))
        #       for(i in 1:999){
        #          # suppressMessages(require(gamlss.dist))
        #          cond <- stats::rpois(n = nrow(new_data),
        #                        lambda = cond_mean)
        #
        ##          sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #          sim_values_mat_i <- matrix(cond, ncol = 1)
        #
        #          # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #          sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        #        }

        # Tadhg lapply
        #set.seed(12345)
        sim_values_list <- lapply(1:999, function(z){
          if(parallel == FALSE){
          #set.seed(as.integer(lapply_seed)+z)
          }
          cond <- stats::rpois(n = nrow(new_data),
                        lambda = cond_mean)
        })
        sim_values_mat <- do.call(cbind, sim_values_list)

        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025))
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975))
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500))
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    # ALTERNATIVE MANUAL METHOD nbinom2
    if(cond_family == "nbinom2" & zinf == TRUE){

      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      zi_prob <- predict(object, newdata=new_data, type="zprob", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      odp <- 1/(glmmTMB::sigma(object)) # note rNBI requires reciprocal of nbinom2 sigma (dispersion parameter), though (slightly frustratingly) this is not the same for NBII!

      # generate random counts from (nbinom2) dist
#      suppressMessages(require(gamlss.dist))
      #set.seed(12345)
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      cond <- gamlss.dist::rNBI(n = nrow(new_data),
                   mu = cond_mean,
                   sigma = odp)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      #set.seed(12345)
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      sim_values <- ifelse(runif(nrow(new_data))< zi_prob, 0, cond)

      # -------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        #       sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
#        suppressMessages(require(gamlss.dist))

        # for(i in 1:999){
        #   suppressMessages(require(gamlss.dist))
        #   cond <- rNBI(n = nrow(new_data),
        #                mu = cond_mean,
        #                sigma = odp)
        #
        #   sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #
        #   # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #   sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        # }
        #set.seed(12345)

        sim_values_list <- lapply(1:999, function(z){
          #if(parallel == FALSE){
          #set.seed(as.integer(lapply_seed)+z)
          #}
          cond <- gamlss.dist::rNBI(n = nrow(new_data),
                       mu = cond_mean,
                       sigma = odp)
        })
        sim_values_mat <- do.call(cbind, sim_values_list)

        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025))
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975))
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500))
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    if(cond_family == "nbinom2" & zinf == FALSE){

      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      #        zi_prob <- predict(object, newdata=new_data, type="zprob", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      odp <- 1/(glmmTMB::sigma(object)) # note rNBI requires reciprocal of nbinom2 sigma (dispersion parameter), though (slightly frustratingly) this is not the same for NBII!

      # generate random counts from (nbinom2) dist
#      suppressMessages(require(gamlss.dist))
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      cond <- gamlss.dist::rNBI(n = nrow(new_data),
                   mu = cond_mean,
                   sigma = odp)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      sim_values <- cond

      # -------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        #        sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
 #       suppressMessages(require(gamlss.dist))

        #         for(i in 1:999){
        #           suppressMessages(require(gamlss.dist))
        #           cond <- rNBI(n = nrow(new_data),
        #                        mu = cond_mean,
        #                        sigma = odp)
        #
        # #          sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #           sim_values_mat_i <- matrix(cond, ncol = 1)
        #
        #
        #           # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #           sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        #         }
        #set.seed(12345)

        sim_values_list <- lapply(1:999, function(z){
          if(parallel == FALSE){
          #set.seed(as.integer(lapply_seed)+z)
          }
          cond <- gamlss.dist::rNBI(n = nrow(new_data),
                       mu = cond_mean,
                       sigma = odp)
        })
        sim_values_mat <- do.call(cbind, sim_values_list)

        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025))
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975))
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500))
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    # ALTERNATIVE MANUAL METHOD nbinom1
    if(cond_family == "nbinom1" & zinf == TRUE){

      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      zi_prob <- predict(object, newdata=new_data, type="zprob", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      odp <- glmmTMB::sigma(object)

      # generate random counts from quasi-poisson (nbinom1) dist
#      suppressMessages(require(gamlss.dist))
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      cond <- gamlss.dist::rNBII(n = nrow(new_data),
                    mu = cond_mean,
                    sigma = odp)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      sim_values <- ifelse(runif(nrow(new_data))< zi_prob, 0, cond)

      # ------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
#        suppressMessages(require(gamlss.dist))

        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        # sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
        #
        # for(i in 1:999){
        #   suppressMessages(require(gamlss.dist))
        #   cond <- rNBII(n = nrow(new_data),
        #                 mu = cond_mean,
        #                 sigma = odp)
        #
        #   sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #
        #   # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #   sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        # }
        #set.seed(12345)

        sim_values_list <- lapply(1:999, function(z){
          #if(parallel == FALSE){
          #set.seed(as.integer(lapply_seed)+z)
          #}
          cond <- gamlss.dist::rNBII(n = nrow(new_data),
                        mu = cond_mean,
                        sigma = odp)
        })
        sim_values_mat <- do.call(cbind, sim_values_list)

        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025))
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975))
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500))
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    if(cond_family == "nbinom1" & zinf == FALSE){

      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      #        zi_prob <- predict(object, newdata=new_data, type="zprob", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      odp <- glmmTMB::sigma(object)

      # generate random counts from quasi-poisson (nbinom1) dist
#      suppressMessages(require(gamlss.dist))
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      cond <- gamlss.dist::rNBII(n = nrow(new_data),
                    mu = cond_mean,
                    sigma = odp)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      sim_values <- cond

      # ------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        #  sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
 #       suppressMessages(require(gamlss.dist))

        # for(i in 1:999){
        #   cond <- rNBII(n = nrow(new_data),
        #                 mu = cond_mean,
        #                 sigma = odp)
        #
        #   #sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #   sim_values_mat_i <- matrix(cond, ncol = 1)
        #
        #
        #   # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #   sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        # }
        #set.seed(12345)

        sim_values_list <- lapply(1:999, function(z){
          if(parallel == FALSE){
          #set.seed(as.integer(lapply_seed)+z)
          }
          cond <- gamlss.dist::rNBII(n = nrow(new_data),
                        mu = cond_mean,
                        sigma = odp)
        })
        sim_values_mat <- do.call(cbind, sim_values_list)

        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025))
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975))
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500))
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    # ALTERNATIVE MANUAL METHOD genpois
    if(cond_family == "genpois" & zinf == TRUE){

      # object = mTrain_genpois
      # X = Train_data_scaled_centred
      #new_data = X
      # pred_type =  "simulate"
      # zinf = TRUE

      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass)
      zi_prob <- predict(object, newdata=new_data, type="zprob", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      odp_sq <- glmmTMB::sigma(object) # phi - squared (see https://rdrr.io/cran/glmmTMB/man/sigma.glmmTMB.html)
      odp <- sqrt(odp_sq)
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      cond <- fishcastr::rgenpoisson(mu = cond_mean,
                          disp_param = odp)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      sim_values <- ifelse(runif(nrow(new_data))< zi_prob, 0, cond)

      # -------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        #sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
        # for(i in 1:999){
        #   cond <- fishcastr::rgenpoisson(mu = cond_mean,
        #                       disp_param = odp)
        #
        #   sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #
        #   # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #   sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        # }

        # Tadhg apply
        #set.seed(12345)
        #lapply_seed
        #unlist(list(1:999))
        #.GlobalEnv$.Random.seed
        #old_state <- get_rand_state()
        #old_state
        #.GlobalEnv$.Random.seed <- x
        #        save.image("C:\\Users\\afrench.INSTITUTE\\WAH2\\Fish_phenology_manuscript\\lapply_seed_assignment.RData")

        sim_values_list <- lapply(1:999, function(z){
          if(use_random_seed == TRUE){
            set.seed(as.integer(lapply_seed)+z)
          }
          cond <- fishcastr::rgenpoisson(mu = cond_mean,
                              disp_param = odp)
        })

        # sim_values_list <- lapply(1:999, function(z){
        #   # calculate seed
        #   #lapply_seed + unlist(x)
        #   #assign(".Random.seed", z, envir=globalenv()) # need to change seed of global environment here as rpois looks in global
        #   set.seed(as.integer(lapply_seed)+z)
        #   #rm(.Random.seed, envir=globalenv())
        #   #assign(x = ".Random.seed", value = as.integer(z), envir = .GlobalEnv)
        #
        #   cond <- fishcastr::rgenpoisson(mu = cond_mean,
        #                       disp_param = odp)
        # })

        sim_values_mat <- do.call(cbind, sim_values_list)
        #View(sim_values_mat)
        #warnings()
        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025), na.rm = TRUE)
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975), na.rm = TRUE)
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500), na.rm = TRUE)
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    if(cond_family == "genpois" & zinf == FALSE & disp_form == "one"){

      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      #        zi_prob <- predict(object, newdata=new_data, type="zprob", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)
      odp_sq <- glmmTMB::sigma(object) # phi squared (see https://rdrr.io/cran/glmmTMB/man/sigma.glmmTMB.html)
      odp <- sqrt(odp_sq)
      # generate random counts from generalised poisson distribution
      #        suppressMessages(require(gamlss.dist))
      if(parallel == FALSE){
      #set.seed(as.integer(lapply_seed))
      }
      cond <- fishcastr::rgenpoisson(mu = cond_mean,
                          disp_param = odp)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      sim_values <- cond

      # -------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        # sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
        #
        # for(i in 1:999){
        #   cond <- fishcastr::rgenpoisson(mu = cond_mean,
        #                       disp_param = odp)
        #
        #   #sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #   sim_values_mat_i <- matrix(cond, ncol = 1)
        #
        #   # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #   sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        # }
        #set.seed(12345)
        sim_values_list <- lapply(1:999, function(z){
          if(use_random_seed == TRUE){
          set.seed(as.integer(lapply_seed)+z)
          }
          cond <- fishcastr::rgenpoisson(mu = cond_mean,
                              disp_param = odp)
        })
        sim_values_mat <- do.call(cbind, sim_values_list)

        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025))
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975))
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500))
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    if(cond_family == "genpois" & zinf == FALSE & disp_form == "modelled"){

      # extract conditional mean
      cond_mean <- predict(object, newdata=new_data, type="conditional", allow.new.levels=TRUE, na.action = na.pass, re.form = NA)

      # extract dispersion parameter as function of fixed effects, noting log link (hence exp())
      f <- formula(object, component = "disp")
      X <- model.matrix(f, data = new_data)
      beta <- glmmTMB::fixef(object)[["disp"]]
      eta <- X %*% beta
      odp <- c(exp(eta))

      # generate random counts from generalised generalised poisson distribution
      if(parallel == FALSE){
        #set.seed(as.integer(lapply_seed))
      }
      cond <- fishcastr::rgenpoisson(mu = cond_mean,
                          disp_param = odp)

      # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
      sim_values <- cond

      # -------------------------------------------------------------------------------------------------- #
      # GENERATE 95% BOOTSTRAPPED PERCENTILE PREDICTION INTERVALS
      # -------------------------------------------------------------------------------------------------- #
      if(PIs == TRUE){
        # generate random counts from quasi-poisson (nbinom1) dist (i.e., stochastic element to forecast)
        # sim_values_mat <- (matrix(nrow = nrow(new_data), ncol = 0))
        #
        # for(i in 1:999){
        #   cond <- fishcastr::rgenpoisson(mu = cond_mean,
        #                       disp_param = odp)
        #
        #   #sim_values_mat_i <- matrix(ifelse(runif(nrow(new_data))< zi_prob, 0, cond), ncol = 1)
        #   sim_values_mat_i <- matrix(cond, ncol = 1)
        #
        #   # generate random number between zero and 1 and if it is below the probability of zi, impute rnbinom
        #   sim_values_mat <- cbind(sim_values_mat,sim_values_mat_i)
        #
        # }
        #set.seed(12345)
        sim_values_list <- lapply(1:999, function(z){
          if(use_random_seed == TRUE){
            set.seed(as.integer(lapply_seed)+z)
          }
          cond <- fishcastr::rgenpoisson(mu = cond_mean,
                              disp_param = odp)
        })
        sim_values_mat <- do.call(cbind, sim_values_list)

        # order each sim value matrix row individually without affecting other rows and extract 2.5th and 97.5th percentiles as bootstrapped CIs, plus 50th percentile as median
        sim_values_low_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.025))
        sim_values_upper_PI <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.975))
        sim_value_median <- apply(sim_values_mat, MARGIN = 1, FUN = quantile, probs = c(0.500))
        sim_values <- data.frame("low_PI" = sim_values_low_PI, "median" = sim_value_median, "upper_PI" = sim_values_upper_PI)
      }
      # -------------------------------------------------------------------------------------------------- #

    }

    return(sim_values)
  }
}
